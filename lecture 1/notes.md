Ключевой Rust особенностью является memory safety. Баги приводят к исключениям, а не к неопределённому поведению. Проверка типов гарантирует отсутствие undefined behavior.


# Runtime

##### Что это такое?
Runtime - это всё то, что есть в программе во время её исполнения, что напрямую в её коде мы не написали.

В разных языках runtime выглядит по-разному, но типичные компоненты такие:
- сборщик мусора
- интерпретатор
- JIT компилятор
- то, как объекты (числа, структуры, массивы) представлены в памяти

##### Плюсы и минусы runtime
Плюсы:
- позволяет нам избавиться от ручного управления памятью - чем больше делает за нас runtime, тем меньше нужно думать нам. 
- время работы программы не важно, если её 90% - это I/O
- избавляет нас от катастрофических ошибок из-за автоматического управления памятью


С другой стороны:
- он забирает производительность - всё зависит от того, насколько она нам нужна
- он громоздкий, deep dive ниже
> Если мы напишем программу на языке с runtime (Java, Python), нам будет сложно заставить их взаимодействовать. Нужно либо делать отдельные процессы или бинарный файл, что линкует JVM и CPython. Будут сложности с двумя сборщиками мусора.
>
>Если мы хотим сдеалть библиотеку для wasm, нам нужно будет скомпилировать туда и сборщик мусора - его нужно будет тащить в неё.
>
>Языки без runtime хороши тем, что их можно использовать всегда и везде.
>
>SQLite написана на Си - её можно вставить в любую программу, что на Java, что на Python.
>
>На девайсах Apple нельзя использовать JIT. Если наш runtime сильно зависит от JIT, с ними мы работать будем хуже. А код без сборщика мусора можно засунуть куда угодно.


##### Философия Rust 
**Zero cost abstractions** - мы пишем на высокоуровневом языке программирования, что может скомпилироваться во что-то эффективное. Это нужно, когда нам нужно экономить ресурсы или куда-то заэмбедиться


Среднее значение массива интов без абстракций:
```rust
fn average(xs: &[i32]) -> f64 {
    let mut sum: i32 = 0;
    for i in 0..xs.len() {
        sum += xs[i];
    }
    sum as f64 / xs.len() as f64
}
// 17 ms
```

С абстракциями:
```rust
fn average(xs: &[i32]) -> f64 {
    xs.iter().fold(0, |x, y| x + y) as f64 / xs.len() as f64
}
// 18 ms
```

В примере было сравнение с кодом на на Java (30 ms) и Scala (> 500 ms)
##### Почему такая разница?

Scala с аналогичным кодом с абстракциями будет работать медленнее, чем Java, поскольку функции в Scala генеричные - дженерики в Java работают только с объектами. По этой причине примитивные инты нужно сначала превратить в объекты Integer, что аллоцируются в heap, и их уже просуммировать.

На Rust оба примера работают быстро из-за **zero cost abstractions**.

Два примера "Hello world":
```rust
fn main() {
    println!("Hello, world!");
}
```

```rust
#![no_main]

#[link_section=".text"]
#[no_mangle]
pub static main: [u32; 9] = [
// numbers
];
```
У Rust есть одна "правильная" система сборки - Cargo, что можно установить через Rustup.


# Основные типы
##### Целые числа

Поскольку Rust - язык низкоуровневый, у нас есть типы различной длины, то есть нам доступны машинные типы:
i8 - u8
i16 - u16
i32 - u32
i64 - u64
i128 - u128
isize - usize


usize - совпадает с размером указателя, который определяет битность процессора.


##### Числа с плавающей точкой
f32, f64

Здесь же f32::NAN или f63::NAN, +Inf, -Inf

**Литералы** - целое число + суффикс:
```rust
let x = 48_000i32; // 48000
let hob = 0xffff + 0o777 + 0b1; // 65535 + 511 + 1 = 66047
let byte = b'x'; // 120
```
-----
##### Арифметика
- арифметические операции: +, -, *, /, %
- битовые/логические: <<, >>, |, &, ^, ! (сдвиги, ИЛИ, И, искл ИЛИ, инверсия)

```rust
// (?) Конвертировать типы лучше через as:
let x: i64 = 24;
let y: i32 = x as i32
```

Переполненине возникает в release, но вызывает панику в debug:
```rust
let x: i32 = i32::max_value();
let y: i32 = x + 5; 
// cargo run
// thread main panicked at attempt to add with overflow

// cargo run --release
// -2147483644
```

```rust
let x = u32::max_value();
let y = x.overflowing_add(5); // tuple (4, true)
println!("{}", y.0);
```


Методы с переполнением:
- **wrapping_add(x)** вычисляет сумму в пределах значений данного типа
- **saturating_add(x)** оставляет результат максимальным вместо переполнения
- **overflowing_add(x)** возвращает кортеж (result, is_overflowed)
- **checked_add(x)** возвращает результат или None в случае переполнения


----

##### Логический тип
let is_true: bool = true;
let is_false: bool = !is_true;

Операторы && и || ленивые. Это означает, что если левая часть определяет выражение, правая выполняться не будет

##### Кортежи
() - аналог void
(i32)
(i32, i64)

```rust
let x = (1, 0.1, 12, true, "Hello!");
let mut a = x.0;

a += 1;

println!("{:?}", x); // (1, 0.1, 12, true, "Hello!")
println!("{:?}", a); // 2
```


Для обращения к элементам кортежей используется синтаксис с точкой:
> tuple.element

Если кортеж состоит из одного элемента, необходимо поставить запятую в конце, иначе мы получим простую переменную с этим типом.


##### Кортежи
[i32; 0]
[i32; 3]
[i32; 10]

Размер массива - константа, часть типа
[i32; 3] - это примерно то же, что и (i8, i8, i8)

##### Ссылки
&T
&mut T

- подробнее в лекции 2
- представление ссылки - указатель
- не может быть NULL
- гарантирует, что объект жив

```rust
let mut x: i32 = 94;
let r: &mut i32 = &mut x;

*r += 1;

println!("{}", r);

/*
Мы создали изменяемый x, равный 94.
Затем создали r - ссылку с доступом изменения на x. Их типы должны совпадать, поэтому r - это &mut i32  на &x, то есть тоже &mut i32

Далее мы разыменовали r - получили его значение, а не адрес, и к нему прибавили 1.
*/
```

##### Указатели
- могут быть NULL
- **не** гарантируют, что объект жив
- разыменовывание - unsafe
- встречаются редко